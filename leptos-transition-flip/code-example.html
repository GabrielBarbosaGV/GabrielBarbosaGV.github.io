<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../favicon.png" />
		<meta name="viewport" content="width=device-width" />
		
		<link href="../_app/immutable/assets/0.28a5e4da.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.ba3cccdf.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.201e1dc2.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/singletons.faa37769.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.e886774f.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.7411febf.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.d5d4a3a6.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CodeBlock.c805c78d.js"><!-- HEAD_svelte-1vhthgi_START --><link href="/themes/prism.css" rel="stylesheet"><script src="/prism.js"></script><!-- HEAD_svelte-1vhthgi_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">


<div class="flex flex-row justify-center items-center"><h1 class="text-3xl">Full leptos_transition_flip example</h1></div>

<div class="mx-40">

<pre>  <code class="language-rust">
    
  use leptos::{
      html::{Div, ElementDescriptor},
      leptos_dom::console_log,
      *,
  };
  use leptos_transition_flip::prepare_flip;
  use std::{collections::HashMap, time::Duration};

  // Struct to contain all the useful information. As we will need to identify each
  // node_ref, we use an usize as a simple key. The ID needs to be
  // Hash + Eq + Clone + Display. Display is necessary for showing errors.
#[derive(Clone)]
  struct ListItem&lt;V>
  where
      V: ElementDescriptor + 'static,
  {
      id: usize,
      text: String,
      node_ref: NodeRef&lt;V>,
  }

  // Example component that does nothing beyond cosmetics. Two lists of elements
  // that can transition among them.
#[component]
  fn App(cx: Scope) -> impl IntoView {
      // A node_ref is necessary for an ancestor component to be the DOM reflow target.
      // This node_ref needs to be reference a Div.
      let reflow_target = create_node_ref(cx);

      let texts = vec!["One", "Two", "Three"];

      // List that houses all the transitioning items.
      let (items, _set_items) = create_signal(
          cx,
          texts
              .into_iter()
              .enumerate()
              .map(|(index, text)| {
                  create_signal(
                      cx,
                      ListItem {
                          id: index,
                          text: text.to_string(),
                          node_ref: create_node_ref::&lt;Div>(cx),
                      },
                  )
              })
              .collect::&lt;Vec&lt;_>>(),
      );

      // Left list that starts with all the elements.
      let (left_items, set_left_items) = create_signal(cx, items());

      // Empty right list
      let (right_items, set_right_items) = create_signal(cx, Vec::new());

      view! { cx,
          &lt;div node_ref=reflow_target class="w-[100vw] h-[100vh] bg-blue-200 flex justify-around items-center">
              &lt;div class="flex justify-around items-center flex-col">
                  &lt;For
                      each=left_items
                      key=move |(item, _)| item().id
                      view=move |cx, (item, _)| {
                          let node_ref = item().node_ref;

                          let move_item_right = move |_| {
                              let id = item().id;

                              // A HashMap is utilized to map the keys to node_refs.
                              let ids_to_node_refs = items()
                                      .into_iter()
                                      .map(|(item, _)| item())
                                      .map(|ListItem { id, node_ref, .. }| (id, node_ref))
                                      .collect::&lt;HashMap&lt;_, _>>();

                              // This is the leptos_transition_flip crate's function. It receives the
                              // aformentioned mapping, the node_ref of the reflow target, and,
                              // finally, the transition property to be set for the target HTML
                              // elements in FLIPping.
                              let (flip, clear) = prepare_flip(
                                  ids_to_node_refs,
                                  reflow_target,
                                  "transform 0.6s".to_string()
                              ).unwrap();

                              // Get item that will be removed>
                              let item = left_items().into_iter().filter(|(i, _)| i().id == id).next().unwrap();

                              // Remove item from left list.
                              set_left_items.update(|items| {
                                  let position = items.iter().position(|(i, _)| i().id == id).unwrap();

                                  items.remove(position);
                              });

                              // Push item into right list.
                              set_right_items.update(|items| {
                                  items.push(item);
                              });


                              // Do FLIP.
                              match flip().map_err(|err| format!("An error has occurred when attempting a FLIP: {err}")) {
                                  Ok(()) => (),
                                  Err(err) => console_log(&amp;err)
                              }

                              // Clear styles after timeout.
                              set_timeout(|| {
                                  match clear().map_err(|err| format!("An error has occurred when attempting to clear the elements' transition styles: {err}")) {
                                      Ok(()) => (),
                                      Err(err) => console_log(&amp;err)
                                  }
                              }, Duration::from_millis(600));
                          };

                          view! { cx,
                              &lt;div node_ref=node_ref class="bg-green-200 my-2 w-[10vw] flex justify-center items-center" on:click=move_item_right>
                                  &lt;span>
                                      {move || item().text}
                                  &lt;/span>
                              &lt;/div>
                          }
                      }
                  />
              &lt;/div>

              &lt;div class="flex flex-col justify-around items-center">
                  &lt;For
                      each=right_items
                      key=move |(item, _)| item().id
                      view=move |cx, (item, _)| {
                          let node_ref = item().node_ref;

                          // Same process described above, but reversing the list positions.
                          let move_item_left = move |_| {
                              let id = item().id;

                              let ids_to_node_refs = items()
                                  .into_iter()
                                  .map(|(item, _)| item())
                                  .map(|ListItem { id, node_ref, .. }| (id, node_ref))
                                  .collect::&lt;HashMap&lt;_, _>>();

                              let (flip, clear) = prepare_flip(ids_to_node_refs, reflow_target, "transform 1s".to_string()).unwrap();

                              let item = right_items().into_iter().filter(|(i, _)| i().id == id).next().unwrap();

                              set_right_items.update(|items| {
                                  let position = items.into_iter().position(|(i, _)| i().id == id).unwrap();

                                  items.remove(position);
                              });

                              set_left_items.update(|items| {
                                  items.push(item);
                              });

                              let _ = flip();

                              set_timeout(|| { let _ = clear(); }, Duration::from_millis(1200));
                          };

                          view! { cx,
                              &lt;div node_ref=node_ref class="bg-green-200 my-2 w-[10vw] flex justify-center items-center" on:click=move_item_left>
                                  &lt;span>
                                      {move || item().text}
                                  &lt;/span>
                              &lt;/div>
                          }
                      }
                  />
              &lt;/div>
          &lt;/div>
      }
  }

  fn main() {
      mount_to_body(|cx| view! { cx, &lt;App /> });
  }
    
  </code>
</pre></div>


			
			<script>
				{
					__sveltekit_1bd5gmx = {
						base: new URL("..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("../_app/immutable/entry/start.ba3cccdf.js"),
						import("../_app/immutable/entry/app.e886774f.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
